# 基本思路
因为原始数据总大小是1T，但不确定数据项数，内存只有4G，所以可能无法将所有数据放到内存中组织一个索引结构。因此采用的方法是将原始数据排序并分片为多个chunk，每一片包含多个已排序的数据项，和这块数据在磁盘上的起始位置及长度。将每个分片的元数据保存存在内存中进行查找，找到元数据后，再去磁盘中读取实际的数据块。每个分片的大小越大，则实际保存的分片元数据数量越小，从而让占用内存更小。在内存中使用一个lru的缓存，来保存每次从磁盘中读出的数据块，如果多个请求对应的数据都位于同一个数据块中，则可以直接从内存中获取。

# 主要结构
* kvPair：保存一个字节数组表示的key-value对
* chunk：表示多个kv对组成的一个数据分片，以及对应的元数据
* chunkMeta：表示一个chunk的元数据，记录了这块chunk分片在磁盘上的起始位置、长度以及起始的key（用来给多个chunk排序）
* DB：表示存储系统，管理多个元数据，以及chunk的lru缓存，同时包含一个singleflight对象来确保并发读取时只读一次磁盘

# 主要函数
* parseOneChunk：用来读取原始文件，并根据一个chunk的规定大小来解析出kv数据，对其排序，返回chunk对象
* dumpOneChunk：用来将一个chunk对象写入磁盘，并记录起始位置等元数据，返回一个chunkMeta对象
* preprocess：启动时的预处理函数，依次解析原始文件生成多个chunk对象，然后对他们进行排序并写入磁盘，然后保存这些chunk的元数据并在内存中排序
* lowerSearchMeta：根据指定key值，执行二分查找找到包含这个key值的那一个chunkMeta
* DB.Init：读取文件并调用preprocess函数进行预处理
* DB.Get：读取接口，指定key值，先在内存中查询出chunkMeta对象，然后根据元数据中判断是否要去读磁盘，还是这个chunk已经被保存在内缓冲中。如果要读磁盘则根据元数据中的信息读取磁盘，然后放入内存缓冲。最后在chunk对象中查询这个指定key并返回value